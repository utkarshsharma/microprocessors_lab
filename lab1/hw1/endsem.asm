ORG 0H
LJMP MAIN

ORG 00CCH
	LJMP ISR0
	
ORG 1000H 
MAIN:
	LCALL INIT_LCD
	MOV TMOD,#10010001B ; Timer 0, Timer 1 in mode 1(16 bit counter)
	;SETB EA				; Enable Interrupts
	;SETB ET0			; Enable Timer 0 Interrupt
	MOV TH1, #00H
	MOV TL1, #00H
	;MOV TH0, #0FFH
	;MOV TL0, #0FFH
	;MOV A, TCON
	;ANL A, #00000010B
;JUMP1: CJNE A, #00H, JUMP1
	;SETB TR0
	;CLR IT0
	
HERE:
	JB P0.7, $
	SETB TR1
	JNB P0.7, $
	JB P0.7, $
	LCALL ISR0
	SJMP HERE
	
ISR0:
	;CLR ET0
	CLR TR1
	MOV R5, TH1
	MOV R6, TL1
	;MOV TH0, #0FFH
	;MOV TL0, #0FFH
	MOV TH1, #00H
	MOV TL1, #00H
	MOV A, #80H         ;START FROM HERE
	LCALL CMD_WRITE
	MOV A, R5
	LCALL WRITE_BYTE
	LCALL DELAY
	MOV A, R6
	LCALL WRITE_BYTE
	LCALL DELAY
	;LCALL DISPLAY
	;LCALL BCDDISPLAY
	;SETB ET0
	;MOV A, TCON
	;ANL A, #00000010B
;JUMP: CJNE A, #00H, JUMP
	
RET


;DISPLAY:
	;MOV A, #1H          ;CLEAR DISPLAY
	;LCALL CMD_WRITE
	;MOV A, #83H         ;START FROM HERE
	;LCALL CMD_WRITE
	;MOV A, R5	
	;LCALL DATA_WRITE
	;MOV A,B
	;LCALL DATA_WRITE
;RET

;BCDDISPLAY:
;NOP
;RET



RS EQU P0.0
RW EQU P0.1
EN EQU P0.2

ORG 50H

CMD_WRITE:  
	ACALL LCD_READY
	MOV P2, A
	CLR RS
	CLR RW
	SETB EN
	LCALL DELAY 
	CLR EN
	RET

DATA_WRITE: 
	ACALL LCD_READY
	MOV P2, A
	SETB RS
	CLR RW
	SETB EN
	LCALL DELAY  ;WILL JUST HELP US SEE CHARACTERS BEING DISPLAYED ONE BY ONE. 
				 ;ALSO, IT MAY ELIMINATE THE NEED FOR LCD_READY/BUSY CHECK!
				 ;BUT IT IS RECOMMENDED TO ALWAYS CHECK FOR LCD_BUSY.
			     ;UNCOMMENT THE CALL TO DELAY IF U WANT TO SEE INDIVIDUAL CHAR
			     ;BEING WRITTEN SLOWLY
	CLR EN
	RET

INIT_LCD:
	MOV A, #38H     ;2 LINE DISPLAY WITH 5x7 FONT ON AN 8BIT INTERFACE
	LCALL CMD_WRITE
	MOV A, #0EH     ;TURN ON DISPLAY, CURSOR NOT BLINKING
	LCALL CMD_WRITE
	MOV A, #06H     ;INCREMENTING THE CURSOR POSITION
	LCALL CMD_WRITE
	MOV A, #1H      ;CLEAR SCREEN
	LCALL CMD_WRITE
	RET

;FOLLOWING SUB-ROUTINE CHECKS BUSY_FLAG AND WAITS TILL LCD IS READY

LCD_READY:
	MOV P2,#0FFH    ;MAKE P2.7 AS INPUT
	CLR RS          ;SELECT COMMAND REGISTER
	SETB RW         ;TO READ FROM LCD
CHECK: 	
	CLR EN
	SETB EN
	JB P2.7, CHECK  ;READ BUSY FLAG UNTIL IT BECOMES ZERO
	CLR EN
	RET
	
DELAY: 

	MOV R1, #0FFH
	MOV R2, #0FFH
L1: 
	NOP 
	DJNZ R1, L1
	DJNZ R2, L1

RET	


DELAY5: 

	MOV R5, #32H
ABC: 
	LCALL DELAY
	DJNZ R5, ABC

	RET

WRITE_BYTE:
LCALL BYTE_ASCII
LCALL DATA_WRITE
MOV A,B
LCALL DATA_WRITE
RET

;ASCII_BCD:
;MOV DPTR, #BCD,TABLE
;MOVC A,@A-DPTR

BYTE_ASCII:
	MOV R7, A
	ANL A, #0FH
	ACALL NIBBLE_ASCII
	MOV B, A

	MOV A, R7
	SWAP A
	ANL A, #0FH
	ACALL NIBBLE_ASCII
	RET
;----------------------------------------------------------------------------
NIBBLE_ASCII:   
	MOV DPTR, #HEX_TABLE
	MOVC A,@A+DPTR
	RET
;----------------------------------------------------------------------------
ORG 400H
HEX_TABLE: DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H,41H,42H,43H,44H,45H,46H
;----------------------------------------------------------------------------



END	
	
	
	

	
