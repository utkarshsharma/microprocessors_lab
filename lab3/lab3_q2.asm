	org 00h
	ljmp main
	USING 0	;ASSEMBLER DIRECTIVE TO INDICATE REGISTER BANK0

	org 50h
main:
	MOV A, #000h		;CLEAR ACC
	MOV R5, #000h		;R5 is going to be our counter for reading Address and Duration from DATA2
	MOV TMOD,#001h		;16 bit counter mode
endofinterrupts:
	LCALL read
;read function called. Program will  now read duration and index from DATA2

	MOV DPTR, #DATA1

loop:
	MOV A,R7
	MOVC A, @A+DPTR			;READING FROM DATA1 USING INDEX STORED IN R7
	MOV R4,A				;LSB
	MOV A, R7
	INC A
	INC R7
	MOVC A, @A+DPTR
	MOV R3,A				;MSB

;THE FUNCTION twoscomp TAKES TWO BYTES AS INPUT IN R3(MSB) ad R4(LSB)
	LCALL twoscomp
;THE FUNCTION twoscomp RETURNS THE 2's COMPLIMENTS OF THE TWO BYTES IN R3(MSB) ad R4(LSB)

;STORING FREQUENCY OF SIGNAL AT TEMPORARY MEMORY LOCATIONS AS TH0 AND TL0 WILL HAVE TO BE RESET AGAIN MANY TIMES UNTIL WE HAVE TO READ AGAIN
;AND R3 AND R4 ARE GOING TO BE USED AGAIN IN SETTING TH1 AND TL1
	MOV 71H,R3
	MOV 72H,R4

;ENABLE INTERRUPTS FOR T1 AND T0
	SETB ET1
	SETB ET0
	SETB EA

;SET FREQUENCY FOR SQUARE WAVE
	MOV TH0,R3
	MOV TL0,R4
	SETB P0.7

	MOV R3, #0ffh
	MOV R4, #0ffh
	LCALL twoscomp

sq_wave:
	LCALL hundredms
	DJNZ R6,sq_wave			;REPEATING 100ms LOOP FOR THE NUMBER OF TIMES REQUIRED
	CLR TR0					;STOP T0 UNTIL WE HAVE READ AGAIN
	LJMP endofinterrupts	;GO BACK TO READING AGAIN

	org 2000h
read:
	PUSH ACC			;PUSH A ONTO THE STACK
readloop:
	MOV A,R5			;COUNTER ON DATA2 MOVED TO A
	MOV DPTR, #DATA2	;DATA POINTER MOVED TO READ FROM DATA2
	MOVC A, @A+DPTR
	MOV B,A

;SEPARATING THE FIRST FOUR BITS FROM THE LAST FOUR BITS
	ANL B,#00fh			;TO BE USED AS INDEX		
	ANL A,#0f0h			;TO BE USED FOR DURATION OF SQUARE WAVE
	SWAP A
	MOV R6,A			;FROM HERE ONWARDS R6 WILL STORE OUR DURATION


	INC R5				;COUNTER INCREASED TO BE USED IN NEXT READ CYCLE

;NEXT PART OF CODE DOUBLES THE INDEX READ FROM THE SWITCH
	MOV A,B
	MOV B,#002H
;MOV A,R0
	MUL AB
	MOV R7,A			;FROM HERE ONWARDS R7 STORES OUR INDEX 
	POP ACC				;POP A BACK FROM THE STACK AFTER SUBROUTINE IS COMPLETED
	RET

twoscomp:			;take bit-by-bitcomplement and add 1
	PUSH ACC
	MOV A,R4			;LSB
	CPL A
	CLR C
	ADD A,#1
	MOV R4,A
	MOV A,R3			;MSB
	CPL A 

	JC carry			;if carry from LSB, jump to carry
	MOV R3,A			;otherwise, take complement directly
	pop ACC
	RET

carry:
	ADD A,#1			;adding carry 1 to complement
	MOV R3,A
	POP ACC
	RET

hundredms:
	PUSH AR1
	SETB TR0						;START TIMER0. SO THE SQUARE WAVE GENERATION STARTS
;MOVING FF TO TH1 AND TL1
	MOV TH1, R3	
	MOV TL1, R4

	SETB TR1						;START TIMER1. STOPS ONLY WHEN 100ms ARE COMPLETED. THIS GIVES US ONE 100ms LOOP.
	MOV R2, #018h					;NO. OF TIMES WE HAVE TO RUN T1 FROM 00 TO FE FOR 100ms
set_t1_again:
	DJNZ R2, t1loop					;CHECKING IF 100ms ARE DONE
	sjmp hundms_done
t1loop:
;RESET TH1 AND TL1 if 100ms NOT UP
	MOV TH1, R3
	MOV TL1, R4
;CHECK TH1 AND STOP IT FROM OVERFLOWING BECAUSE 100ms ARE NOT UP
check_th1:
	MOV R1, TH1
	CJNE R1, #0feh, check_th1
	SJMP set_t1_again
;NOW 100ms ALMOST DONE. WAIT FOR INTERRUPT1 TO BE CALLED. THAT IS, TR1 TO BECOME 0.
hundms_done:
	CLR C
	MOV C, TR1
	JNC exit;condition check for whether we have to move on to the next address by reading from the new array
	SJMP  hundms_done;if not then keep doing nothing and let the two interrupts do their job
exit:
	POP AR1
	RET

;INTERRUPT ROUTINE FOR TIMER0
	org 000Bh
ISR0:
	CLR		TR0				;STOP T0 FROM OVERFLOWING AGAIN BEFORE P0.7 IS INVERTED			
	MOV		TH0,71H			;RESET TH0 AND TL0 FROM VALUE OF FREQ STORED AT TEMPORARY MEMORY LOCATION	
	MOV		TL0,72H
	CPL		P0.7
	SETB	TR0				;START T0 AGAIN
	RETI

;INTERRUPT ROUTINE FOR TIMER1
	org 001Bh
ISR1:
	CLR TR1
	RETI


;DATA STORED IN EXTERNAL MEMORY LOCATIONS
	org 5000h
DATA1:
	DB 1AH, 11H, 24H, 10H, 3CH, 0FH, 61H, 0EH, 93H, 0DH, 0CFH, 0CH, 17H, 0CH, 6AH, 0BH, 0C6H, 0AH, 2BH, 0AH, 99H, 09H, 0FH, 09H, 8DH, 08H, 12H, 08H, 9EH, 07H, 31H, 07H

	org 6000h
DATA2:
	DB 0F2H, 0F4H, 0F6H, 0F7H, 0F9H, 0FBH, 0FDH, 0FEH, 0FEH, 0FEH, 0FDH, 0FBH, 0F9H, 0F7H, 0F6H, 0F4H, 0F2H, 0F2H, 02H

	END